'''
Version Information From Git.

Version parsing rules intended to be compliant with PEP-440 and current
python expectations.

PEP-440 specifies: [N!]N(.N)*[{a|b|rc}N][.postN][.devN] for a version format.
This module does not support epoch [N!] portion.
'''
#
# Copyright 2009 Dan Smith <dsmith@danplanet.com>
# minor mods 2015-2020 by Maurizio Andreotti iz2lxi
#                         <maurizioandreottilc@gmail.com>
# Copyright 2021-2025 John. E. Malmberg - Python3 Conversion
#
# This module contains the d-rats version variables

# WL2K requires that programs that communicate with it use N.N.N format where
# N is a digit.

# The version number will be generated by "git describe --tags --dirty" when
# running out of a directory created from a git repository and parsed
# for PYthon compliance.
# https://packaging.python.org/en/latest/discussions/versioning/

# This means that git tags need to follow a convention compliant
# with python.  A 'v' prefix is allowed for more readability.
# The EPOCH "N!" will be ignored as we have no reason to set an
# EPOCH in the foreseeable future.
# The ".post" and ".dev" should not normally be used in git tags.

# When the git metadata is not available the version data is expected
# to be in the PKG-INFO file generated by the packaging process and the
# packaging process is expected to have been run from a directory created
# from a checkout of a git repository.

# If the PKG-INFO file has not been generated, this means that source
# was from an archive of the git repository, and will fall back to
# being the default version specified in this file, and for PEP-440
# will have a ".devN" appended where N is the modification date of this file.

import logging
from os import remove
from os.path import basename
from os.path import dirname
from os.path import exists
from os.path import join
from os.path import realpath
import re
import subprocess

# A check of a small sample of systems, show that there are three
# versions of TOML available.
# The pyproject.toml is used as the one source of truth for information
# to put in the about dialog.
TOML = None
try:
    import tomllib
    TOML = tomllib
except ModuleNotFoundError:
    try:
        import toml  # type: ignore
        TOML = toml
    except ModuleNotFoundError:
        # pass
        try:
            import tomli  # type: ignore
            TOML = tomli
        except ModuleNotFoundError:
            pass

if not '_' in locals():
    import gettext
    _ = gettext.gettext

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)


class VersionGit:
    '''Version from Git.'''

    VERSION_NUM_DEFAULT = "0.0.0dev0+unknown"
    _version_re = re.compile('^Version: (.+)$', re.M)

    def __init__(self, project_path: str = None, logger = None) -> None:
        self._tag = ''
        if logger:
            self.logger = logger
            self._tag = 'VersionGit:'
        else:
            self.logger = logging.getLogger('VersionGit')
        self._version = {}
        self._full_version = None
        self._toml = {}
        self._project_info = {}
        if not project_path:
            project_path = dirname(__file__)
        self._project_path = project_path

    def _info(self, msg: str, *args, **kwargs):
        my_msg = self._tag + msg
        self.logger.info(my_msg, *args, **kwargs)

    def _debug(self, msg: str, *args, **kwargs):
        my_msg = self._tag + msg
        self.logger.debug(my_msg, *args, **kwargs)

    @staticmethod
    def find_in_path(name: str, start_path: str = None) -> str:
        '''
        Find in filename in path.

        Searches a path for a file name.  The default path
        is the filename for this module.
        '''
        if not start_path:
            start_path = dirname(__file__)
        current_path = start_path
        while True:
            file_path = join(current_path, name)
            if exists(file_path):
                return file_path

            parent_path = dirname(current_path)
            if parent_path == current_path:
                return None
            current_path = parent_path

    def _get_toml_authors(self, pyproject_data, authors_key):
        authors = pyproject_data['project'][authors_key]
        author_names = ''
        for author in authors:
            if author_names:
                author_names += ', '
            author_names += author['name']
        self._toml[authors_key] = author_names

    def _get_toml_urls(self, urls):
        for url_key in urls:
            self._toml[url_key] = urls[url_key]

    def _get_toml_license(self, pyproject_data):
        classifiers = pyproject_data['project']['classifiers']
        for classifier in classifiers:
            if classifier.startswith('License ::'):
                self._toml['license'] = classifier.split(" :: ")[2]

    def _get_toml_data(self):
        if self._toml:
            return
        if not TOML:
            self._info('Unable to read pyproject.toml, missing a toml package')
            # Only want to warn once.
            self._toml['valid'] = False
            return
        pyproject_file = self.find_in_path(name='pyproject.toml',
                                           start_path=self._project_path)
        if not pyproject_file:
            self._info('No pyproject.toml file found!')
            self._toml['valid'] = False
            return
        read_type = "rb"
        encoding = None
        if TOML.__name__ == 'toml':
            read_type = "r"
            encoding = "utf-8"
        with open(pyproject_file, read_type, encoding=encoding) as file_handle:
            pyproject_data = TOML.load(file_handle)
            self._toml['project_name'] = \
                        pyproject_data['project']['name']
            self._toml['description'] = \
                        pyproject_data['project']['description']
            self._get_toml_authors(pyproject_data, 'authors')
            self._get_toml_authors(pyproject_data, 'maintainers')
            self._get_toml_license(pyproject_data)
            if 'urls' in pyproject_data['project']:
                urls = pyproject_data['project']['urls']
                self._get_toml_urls(urls)
            if self._toml:
                self._toml['valid'] = True
            else:
                self._info("No data read from %s.", pyproject_file)
                self._toml['valid'] = False

    def _get_short_version(self):
        self._get_version()
        # short version string
        if 'short_version' not in self._version:
            self._version['short_version'] = \
                f"{self._version['major']}.{self._version['minor']}." + \
                f"{self._version['patch']}"

    def _get_project_info(self):
        if self._project_info:
            return
        self._get_toml_data()
        self._project_info['name'] = self._toml['project_name']
        self._project_info['full_version'] = self.full_version
        self._project_info['description'] = self._toml['description']
        self._project_info['authors'] = self._toml['authors']
        self._project_info['maintainers'] = self._toml['maintainers']
        self._project_info['license'] = self._toml['license']
        if self._toml['Homepage']:
            self._project_info['homepage'] = self._toml['Homepage']
        if self._toml['Repository']:
            self._project_info['repository'] = self._toml['Repository']
        if self._toml['Issues']:
            self._project_info['issues'] = self._toml['Issues']
        if self._toml['Documentation']:
            self._project_info['documentation'] = self._toml['Documentation']

    @property
    def project_info(self) -> dict:
        '''
        :returns: A dictionary of program information
        '''
        self._get_project_info()
        return self._project_info

    @property
    def toml(self) -> dict:
        '''
        :returns: A dictionary of information collected from pyproject.toml
        '''
        self._get_toml_data()
        return self._toml

    @property
    def short_version(self):
        '''
        :returns: short 3 digit version number separated by dots
        :rtype: str
        '''
        if 'short_version' not in self._version:
            self._get_short_version()
        return self._version['short_version']

    def _get_pep440_version(self):
        self._get_version()
        if 'short_version' not in self._version:
            self._get_short_version()
        pep440 = self._version['short_version']
        if self._version['revision']:
            pep440 += self._version['revision']
        if self._version['alpha']:
            pep440 += self._version['alpha']
        if self._version['beta']:
            pep440 += self._version['beta']
        if self._version['candidate']:
            pep440 += self._version['candidate']
        if self._version['post']:
            pep440 += self._version['post']
        if self._version['dev']:
            pep440 += self._version['dev']
        elif self._version['commits']:
            # The git describe commits count is used for a dev section.
            pep440 += ".dev{self._version['commits']}"
        self._version['pep440'] = pep440
        dot_git_path = self.find_in_path(name='.git',
                                         start_path=self._project_path)
        if dot_git_path:
            # We need to know if we are running from a git checkout, in that
            # case we want to use the data from the git checkout directory
            # instead of data from a previous package install.
            setup_version = join(self._project_path, 'setup_version.py')
            with open(setup_version, 'w', encoding="utf-8") as version_file:
                version_file.write("'''Setup Version.'''\n")
                version_file.write("# This file generated by version_git.py\n")
                version_file.write(
                    f'SETUP_VERSION = "{self._version["pep440"]}"\n')
                self.logger.debug('Created %s', setup_version)
        else:
            self._info('Unable to find .git directory in %s',
                       self._project_path)

    @property
    def pep440_version(self):
        '''
        :returns: PEP 440 compliant version string
        :rtype: str
        '''
        # pep044 version string, not enforcing all rules.
        if 'pep440' not in self._version:
            self._get_pep440_version()
        if not self._toml:
            self._get_toml_data()
        return self._version['pep440']

    def _get_full_version(self):
        if 'pep440' not in self._version:
            self._get_pep440_version()
        if not self._toml:
            self._get_toml_data()
        self._full_version = self._version['pep440']
        if self._version['git_hash']:
            self._full_version += '-' + self._version['git_hash']
        if self._version['dirty']:
            self._full_version += self._version['dirty']

    @property
    def full_version(self):
        '''Full version for display in the program.'''
        if not self._full_version:
            self._get_full_version()
        return self._full_version

    def _extra_dev_parsing(self):
        '''Special extra dev parsing.'''
        if not self._version['extra']:
            return
        # This is somehow missed in the above regex sometimes.
        if not self._version['dev']:
            release_re = re.search(r'(dev\d+)?(.*)?',
                                   self._version['extra'])
            if release_re.group(1):
                self._version['dev'] = '.' + release_re.group(1)
                self._version['extra'] = release_re.group(2)

    def _extra_parsing(self):
        '''
        Extra Parsing of version dictionary.
        '''
        if not self._version['extra']:
            return
        # Handle some non PEP-440 compliant tags
        regex0 = r'^(?:(?:\.)?(a\d+)?(b\d+)?(r?c\d+)?)?(.*)?'
        release0_re = re.search(regex0, self._version['extra'])
        self._version['alpha'] = release0_re.group(1)
        self._version['beta'] = release0_re.group(2)
        self._version['candidate'] = release0_re.group(3)
        self._version['extra'] = release0_re.group(4)
        if not self._version['extra']:
            return

        # Look for PEP-440 compliant release
        regex = r'^(?:(\.\d+)*)?' + \
                r'(a\d+)?(b\d+)?(r?c\d+)?(.dev\d+)?(.post\d+)?(.*)?'
        release_re = re.search(regex, self._version['extra'])
        self._version['revision'] = release_re.group(1)
        self._version['dev'] = release_re.group(2)
        if not self._version['alpha']:
            self._version['alpha'] = release_re.group(3)
        if not self._version['beta']:
            self._version['beta'] = release_re.group(4)
        if not self._version['candidate']:
            self._version['candidate'] = release_re.group(5)
        self._version['post'] = release_re.group(6)
        self._version['extra'] = release_re.group(7)

        self._extra_dev_parsing()
        if not self._version['extra']:
            return
        # If this is from git-describe and not on a version tag,
        # then there will be some optional text, a dash, a number
        # a second dash followed by a git hash beginning with a letter g.
        # with a possible "-dirty" if there are un-committed changes
        # to the repository
        git_regex = r'^([^-]*)?(?:\-(\d+))?(?:-(g[^-]+))?(-dirty)?(.*)?'
        git_re = re.search(git_regex, self._version['extra'])
        if git_re:
            self._version['commits'] = git_re.group(2)
            self._version['git_hash'] = git_re.group(3)
            self._version['dirty'] = git_re.group(4)
            self._version['extra'] = git_re.group(1)

        if not self._version['extra']:
            return
        # Try to fix up old git tags and version issues
        old_regex = r'^\s*(beta|alpha)?(\d+)?(.*)?'
        old_re = re.search(old_regex, self._version['extra'])
        if not old_re:
            return
        key = old_re.group(1)
        if not key:
            return
        if not self._version[key]:
            beta_num = '1'
            if old_re.group(2):
                beta_num = old_re.group(2)
                self._version[key] = 'b' + beta_num
                self._version['extra'] = old_re.group(3)

    def _parse_version(self, raw_version):
        '''
        Parse the version string into parts.

        :param raw_version: Raw version string
        :type raw_version: str
        :returns: Dictionary numeric version and extra version
        :rtype: dict
        '''
        self._version = {}
        self._version['epoch'] = None
        self._version['major'] = 0
        self._version['minor'] = 0
        self._version['patch'] = 0
        self._version['revision'] = None
        self._version['dev'] = None
        self._version['alpha'] = None
        self._version['beta'] = None
        self._version['post'] = None
        self._version['candidate'] = None
        self._version['commits'] = None
        self._version['dirty'] = None
        self._version['git_hash'] = None
        self._version['extra'] = ''
        # we do not enforce PEP-440, as we want to be more liberal here.
        version_re = re.search(r'^v?(\d+!)?(\d+)?\.?(\d+)?\.?(\d+)?(.+)?',
                               raw_version)
        self._version['epoch'] = version_re.group(1)
        find_version = True
        for group_num in range(2, version_re.lastindex + 1):
            part = version_re.group(group_num)
            if find_version:
                # We do not know how many numeric version numbers separated
                # by dots that there will be.
                # for w2lk we need to capture the first three.
                try:
                    part_num = int(part)
                    if group_num == 2:
                        self._version['major'] = part_num
                        continue
                    if group_num == 3:
                        self._version['minor'] = part_num
                        continue
                    if group_num == 4:
                        self._version['patch'] = part_num
                        continue
                except ValueError:
                    find_version = False
        if self._version['extra']:
            self._version['extra'] += '.'
        self._version['extra'] += part
        self._extra_parsing()

    def _update_pkg_info(self, file_name):
        '''
        Update the pkg_info file if needed.

        :param file_name: Filename of pkg_info file.
        :type file_name: str
        '''
        try:
            # Extract the version from the PKG-INFO file.
            with open(file_name, encoding="utf-8") as file_handle:
                raw_version = self._version_re.search(
                    file_handle.read()).group(1)
                if raw_version != self._version['pep440']:
                    remove(file_name)
                    return
        except OSError:
            pass
        # Minimal PKG-INFO file, packaging like RPM/Debian packages
        # should create a more detailed file.
        with open(file_name, 'w', encoding="utf-8") as file_handle:
            file_handle.write('Metadata-Version: 1.0\n')
            file_handle.write(f"Name: {self._toml['project_name']}\n")
            file_handle.write(f"Version: {self._version['pep440']}\n")
            file_handle.write(f"Summary: {self._toml['description']}\n")
            file_handle.write(f"Home-page: {self._toml['Homepage']}\n")
            file_handle.write(f"Author: {self._toml['authors']}\n")
            file_handle.write(f"License: {self._toml['license']}\n")
            file_handle.write(f"Description: {self._toml['description']}\n")

    @staticmethod
    def _dynamic_import(module_name, file_path):
        # comments below suppresses pylint and pylance diagnostics
        # because this module is not in the checked out source tree
        # pylint: disable=import-outside-toplevel
        import importlib.util
        # pylint: disable=import-outside-toplevel
        import sys
        spec = importlib.util.spec_from_file_location(module_name, file_path)
        module = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = module
        spec.loader.exec_module(module)
        return module

    def _get_version(self):
        '''
        Get version number.

        If we are running from a git repository checkout, get the version
        number from the git repository.

        Otherwise try to get it from the file generated by setuptools.

        Finally fall back to a default in this module.
        '''
        if self._version:
            return
        file_dir = dirname(__file__)
        module_dir = dirname(file_dir)
        pkg_info_file = join(module_dir, 'PKG-INFO')

        # Get the version using "git describe".
        cmd = 'git describe --tags --dirty'
        cmd = cmd.split()
        try:
            raw_version = subprocess.check_output(cmd).decode().strip()
            self._parse_version(raw_version)
            self._get_pep440_version()
            self._get_toml_data()
            self._update_pkg_info(pkg_info_file)
            self._info('Able to get version number from git tags')
        except (FileNotFoundError, subprocess.CalledProcessError):
            self._info('Unable to get version number from git tags')

        if not self._version:
            self._debug('Not running from a git repository')
            # The new python build procedure will add setup_version.py
            try:
                my_dir = realpath(dirname(__file__))
                setup_path = join(my_dir, 'setup_version.py')
                setup_info = self._dynamic_import('setup_version',
                                                 setup_path)
                self._parse_version(setup_info.SETUP_VERSION)
            except AttributeError:
                self._info('Unable find a SETUP_VERSION module')

        if not self._version:
            try:
                # Extract the version from the PKG-INFO file.
                with open(pkg_info_file, encoding='utf-8') as file_handle:
                    raw_version = self._version_re.search(
                        file_handle.read()).group(1)
                    self._parse_version(raw_version)

            except OSError:
                self._info('Could not get an accurate version.')
                raw_version = self.VERSION_NUM_DEFAULT
                self._parse_version(raw_version)


GLOBAL_VERSION = VersionGit()

__version__ = GLOBAL_VERSION.pep440_version


def main():
    '''Main package for testing.'''

    logger = logging.getLogger(basename(__file__))

    logger.info("Name:            %s", GLOBAL_VERSION.project_info['name'])
    logger.info("Version:         %s", GLOBAL_VERSION.full_version)
    logger.info("PEP440_VERSION:  %s", GLOBAL_VERSION.pep440_version)
    logger.info("Description:     %s", GLOBAL_VERSION.toml['description'])
    logger.info("Authors:         %s", GLOBAL_VERSION.toml['authors'])
    logger.info("Maintainers:     %s", GLOBAL_VERSION.toml['maintainers'])
    logger.info("License:         %s", GLOBAL_VERSION.toml['license'])
    logger.info("Website:         %s", GLOBAL_VERSION.toml['Homepage'])
    logger.info("Repository:      %s", GLOBAL_VERSION.toml['Repository'])
    logger.info("Issues:          %s", GLOBAL_VERSION.project_info['issues'])
    logger.info("Documentation:   %s", GLOBAL_VERSION.toml['Documentation'])

if __name__ == "__main__":
    main()
